#!/bin/sh

#
# optionally provide flashing whole disk image in INITRAMFS context
#

# Flash Mode
#     1    flash disk image from network to active block device
#     2    clone disk image from active block device to other one
#
ICS_DM_FLASH_MODE=""

ICS_DM_FLASH_MODE_VAR="flash-mode"
ICS_DM_FLASH_DEVPATH_VAR="flash-mode-devpath"
ICS_DM_FLASH_MODE_FLAG_FILE="/etc/enforce_flash_mode"
ICS_DM_FLASH_MODE_FIFO="/home/ics-dm/wic.xz"
ICS_DM_FLASH_MODE_BMAP_FILE="/home/ics-dm/wic.bmap"

# variable templates
ICS_DM_FLASH_MODE_ETH="eth0"
ICS_DM_FLASH_MODE_BOOTLOADER_START=""  # optionally, start of bootloader area
ICS_DM_FLASH_MODE_UBOOT_ENV1_START=""  # start of  first u-boot environment
ICS_DM_FLASH_MODE_UBOOT_ENV2_START=""  # start of second u-boot environment
ICS_DM_FLASH_MODE_UBOOT_ENV_SIZE=""    # size of u-boot environment

# called by generic INITRAMFS
flash_mode_enabled() {
    # flash mode fixed part of the initramfs image
    if [ -f ${ICS_DM_FLASH_MODE_FLAG_FILE} ]; then
        msg "enable flash mode: by ${ICS_DM_FLASH_MODE_FLAG_FILE}"
        ICS_DM_FLASH_MODE=1
        return 0  # enable flash mode; call main entry point
    fi

    # flash mode triggered at runtime
    ICS_DM_FLASH_MODE=$(get_bootloader_env_var ${ICS_DM_FLASH_MODE_VAR})
    if [ -n "${ICS_DM_FLASH_MODE}" ]; then
        msg "enable flash mode: by u-boot environment variable ${ICS_DM_FLASH_MODE_VAR}: ${ICS_DM_FLASH_MODE}"
        return 0  # enable flash mode; call main entry point
    fi

    return 1  # disable flash mode; normal boot; main entry point _NOT_ called
}

setup_network() {
    local if_name="$1"
    local ip_addr=""

    # get network interface up
    while true; do
        ifconfig ${if_name} up >/dev/null 2>&1
        if [ $? -eq 0 ]; then break; fi
        msg "Waiting for ${if_name} ..."
        sleep 1
    done

    # start dhcp client; it is backgrounding in the case the IP address was assigned or timeout
    mkdir -p /tmp
    run_cmd dhcpcd ${if_name} || return 1

    # wait for IPv4 address
    while true; do
        msg "Waiting for IP address..."
        ip_addr=$(ip addr show dev ${ICS_DM_FLASH_MODE_ETH} | grep "inet " | awk '{print $2}')
        if [ ! -z "${ip_addr}" ]; then break; fi
        sleep 1
    done
    ICS_DM_FLASH_MODE_IP_ADDR="${ip_addr%/*}"

    # setup PTY
    run_cmd mkdir -p /dev/pts || return 1
    run_cmd mount -t devpts devpts /dev/pts || return 1

    # start SSH server; generate host key on the fly
    mkdir -p /etc/dropbear
    run_cmd dropbear -R || return 1
}

run_bmap_tool() {
    local umount_dev=""
    local blk_dev=""

    # detect block device
    blk_dev=$(get_block_device boot)
    blk_dev=${blk_dev%p*}
    if [ ! -b "${blk_dev}" ]; then msg_fatal "${blk_dev} does not exist or not a block device"; return 1; fi

    # setup FIFO
    run_cmd mkfifo ${ICS_DM_FLASH_MODE_FIFO} || return 1
    run_cmd chown ics-dm:ics-dm ${ICS_DM_FLASH_MODE_FIFO} || return 1

    # bmap file must be copied with scp
    msg "please run  scp <your-bmap-file> ics-dm@${ICS_DM_FLASH_MODE_IP_ADDR}:$(basename ${ICS_DM_FLASH_MODE_BMAP_FILE})"
    while true; do
        if [ -f "${ICS_DM_FLASH_MODE_BMAP_FILE}" ]; then break; fi
        sleep 1
    done

    # umount, if necessary
    mkdir -p /tmp
    cp /proc/mounts /tmp/all_mounts  # make snapshot
    while read x; do
        umount_dev=$(echo $x | awk '{print $1}')
        echo ${umount_dev} | grep -q "$(basename ${blk_dev})"
        if [ $? -eq 0 ]; then
            echo "umount ${umount_dev}"
            umount ${umount_dev} 2>/dev/null
        fi
    done </tmp/all_mounts

    msg "please run  scp <your-wic-image> ics-dm@${ICS_DM_FLASH_MODE_IP_ADDR}:$(basename ${ICS_DM_FLASH_MODE_FIFO})"
    export PATH
    run_cmd bmaptool copy --bmap ${ICS_DM_FLASH_MODE_BMAP_FILE} \
                                 ${ICS_DM_FLASH_MODE_FIFO} ${blk_dev} || return 1

    return 0  # success
}

# deploy WIC image via network to (same) active block device
run_flash_mode_1() {
    msg "Entering ICS DM flashing mode 1 ..."

    # disable flash mode for subsequent restarts
    set_bootloader_env_var ${ICS_DM_FLASH_MODE_VAR}

    setup_network ${ICS_DM_FLASH_MODE_ETH} || return
    run_bmap_tool || return

    sync
    msg "Rebooting system..."
    reboot -f
    # -- never reached --
}

# clone active disk image to other block device
run_flash_mode_2() {
    local dev_path=""
    local part_type=""
    local blk_dev_dst=""
    local blk_dev_src=""
    local data_partition=""
    local rootfs_bootpart=""
    local act_rootfs_partition=""

    msg "Entering ICS DM flashing mode 2 ..."

    # disable flash mode for subsequent restarts
    set_bootloader_env_var ${ICS_DM_FLASH_MODE_VAR}

    if [ -z "${ICS_DM_FLASH_MODE_UBOOT_ENV1_START}" ]; then msg_fatal "missing definition ICS_DM_FLASH_MODE_UBOOT_ENV1_START"; return; fi
    if [ -z "${ICS_DM_FLASH_MODE_UBOOT_ENV2_START}" ]; then msg_fatal "missing definition ICS_DM_FLASH_MODE_UBOOT_ENV2_START"; return; fi
    if [ -z "${ICS_DM_FLASH_MODE_UBOOT_ENV_SIZE}"   ]; then msg_fatal "missing definition ICS_DM_FLASH_MODE_UBOOT_ENV_SIZE";   return; fi

    # detect destination block device for device path
    dev_path=$(get_bootloader_env_var ${ICS_DM_FLASH_DEVPATH_VAR} | cut -d= -f2)
    if [ -z "${dev_path}" ]; then
        msg_fatal "bootloader environment variable \"${ICS_DM_FLASH_DEVPATH_VAR}\" not set"
        return 1
    fi
    set_bootloader_env_var ${ICS_DM_FLASH_DEVPATH_VAR}
    for i in $(seq 1 30); do
        blk_dev_dst=$(udevadm info --query=property --path="${dev_path}" | grep ^DEVNAME= | cut -d= -f2)
        if [ -n "${blk_dev_dst}" ]; then break; fi
        sleep 1
    done
    if [ ${i} -eq 30 ]; then
        msg_fatal "cannot detect block device from device path \"${dev_path}\""
        return 1
    fi

    # detect source block device
    blk_dev_src=$(get_block_device boot)
    blk_dev_src=${blk_dev_src%p*}
    if [ ! -b "${blk_dev_src}" ]; then msg_fatal "${blk_dev_src} does not exist or not a block device"; return 1; fi

    # detect current rootfs
    rootfs_bootpart=$(get_bootloader_env_var bootpart | cut -d= -f2)
    case "${rootfs_bootpart}" in
      2) act_rootfs_partition="/dev/ics_dm/rootA";;
      3) act_rootfs_partition="/dev/ics_dm/rootB";;
      *) msg_fatal "cannot detect rootfs bootpart"; return 1;;
    esac

    # check for MBR partition type
    part_type=$(parted ${blk_dev_src} print | grep '^Partition Table:' | awk -F: '{print $2}')
    part_type="${part_type// /}"
    if [ ! "${part_type}" == 'msdos' ]; then
        msg_fatal "partition type \"${part_type}\" not supported"
        return 1
    fi

    data_partition=$(readlink -f /dev/ics_dm/data)
    if [ -z "${data_partition}" ]; then
        msg_fatal "cannot detect data partition"
        return 1
    fi

    extended_partition=$(readlink -f /dev/ics_dm/extended)
    if [ -z "${extended_partition}" ]; then
        msg_fatal "cannot detect extended partition"
        return 1
    fi

    msg "######## cloning disk: ${blk_dev_src} -> ${blk_dev_dst} ########"

    msg "CLONE MBR..."  # set data partition to start size
    if ! sfdisk -d "${blk_dev_src}" | \
             sed "s|\(^${data_partition}.*size=[[:space:]]\+\)\([[:digit:]]\+,\)\(.*\)$|\1 1048576, \3|g" | \
                 sed "s|\(^${extended_partition}.*size=[[:space:]]\+\)\([[:digit:]]\+,\)\(.*\)$|\1 1318914, \3|g" | \
                     sfdisk "${blk_dev_dst}"; then
        msg_fatal "clone MBR failed"
        return 1
    fi

    # handle hidden u-boot
    if [ -n "${ICS_DM_FLASH_MODE_BOOTLOADER_START}" ] && [ -n "${ICS_DM_FLASH_MODE_UBOOT_ENV1_START}" ]; then
        msg "COPY u-boot..."
        run_cmd dd if=${blk_dev_src} iflag=skip_bytes skip=$((${ICS_DM_FLASH_MODE_BOOTLOADER_START}*1024)) \
                   of=${blk_dev_dst} oflag=seek_bytes seek=$((${ICS_DM_FLASH_MODE_BOOTLOADER_START}*1024)) \
                   bs=1024 count=$((ICS_DM_FLASH_MODE_UBOOT_ENV1_START - ICS_DM_FLASH_MODE_BOOTLOADER_START))
    fi

    msg "COPY boot, factory, cert and etc..."
    run_cmd dd if=/dev/ics_dm/boot    of="$(readlink -f ${blk_dev_dst}p1)" bs=10M || return 1
    run_cmd dd if=/dev/ics_dm/factory of="$(readlink -f ${blk_dev_dst}p5)" bs=10M || return 1
    run_cmd dd if=/dev/ics_dm/cert    of="$(readlink -f ${blk_dev_dst}p6)" bs=10M || return 1
    run_cmd dd if=/dev/ics_dm/etc     of="$(readlink -f ${blk_dev_dst}p7)" bs=10M || return 1

    msg "COPY current rootfs to rootfsA..."
    run_cmd e2image -ra -p "${act_rootfs_partition}" "$(readlink -f ${blk_dev_dst}*2)" || return 1

    msg "ENFORCE default bootloader environment..."
    run_cmd dd if=/dev/zero bs=1024 count=${ICS_DM_FLASH_MODE_UBOOT_ENV_SIZE} | tr "\000" "\377" >/tmp/uboot_env_ff.img
    run_cmd dd if=/tmp/uboot_env_ff.img of="${blk_dev_dst}" oflag=seek_bytes seek=$((${ICS_DM_FLASH_MODE_UBOOT_ENV1_START}*1024)) || return 1
    run_cmd dd if=/tmp/uboot_env_ff.img of="${blk_dev_dst}" oflag=seek_bytes seek=$((${ICS_DM_FLASH_MODE_UBOOT_ENV2_START}*1024)) || return 1

    run_cmd sync
    return 0
}

# main entry point
flash_mode_run() {
    case ${ICS_DM_FLASH_MODE} in
        1) run_flash_mode_1
           ;;
        2) set -o pipefail
           run_flash_mode_2 2>&1 | tee /tmp/flash-mode-2.log; RET=$?
           setup_rootfs_partition "${ROOTFS_DIR}" "defaults,noatime,nodiratime,async,rw" 
           run_cmd cp /tmp/flash-mode-2.log ${ROOTFS_DIR}/boot/flash-mode-2.log
           run_cmd sync
           run_cmd umount "${ROOTFS_DIR}"
           if [ $RET -eq 0 ]; then run_cmd /bin/sh; fi
           ;;
        *) msg "flash mode \"${ICS_DM_FLASH_MODE}\" not supported; ignore...";;
    esac

    # continue startup in case of errors
    return 0
}
