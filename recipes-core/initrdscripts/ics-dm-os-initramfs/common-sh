#
# common helper functions
#

common_sh_enabled()
{
    return 1  # there is no entry point in this library
}

msg_fatal() {
    msg "FATAL ERROR: $1"
}

run_cmd() {
    msg  "$@"
    eval "$@"
    if [ $? -ne 0 ]; then msg_fatal "command failed"; return 1; fi
    return 0
}

# check ext4 filesystem
# re-format partition in the case of uncorrectable fsck errors or enforced flag
check_ext4_fs()
{
    local   ext4_label=$1  # filesystem label
    local block_device=$2  # block device name
    local enforce_mkfs=$3  # enforce reformatting: 0|1
    local fsck_res=0

    msg "check_ext4_fs ${ext4_label} ${block_device}"

    if [ -z "${block_device}" ] || [ ! -b "${block_device}" ]; then
        msg_fatal "\"${block_device}\" not a valid block device"
        return 1
    fi

    if [ ${enforce_mkfs} -eq 0 ]; then
        # regular boot; fsck handles unclean state (i.e.; not unmounted)
        fsck.ext4 -y ${block_device}
        fsck_res=$?
    fi

    if [ ${enforce_mkfs} -eq 1 ] || [ ${fsck_res} -gt 2 ]; then
        # -- mkfs enforced OR uncorrectable fsck errors --
        msg "reformatting ${block_device} [fsck_res=${fsck_res}, enforce_mkfs=${enforce_mkfs}] ..."
        run_cmd mkfs.ext4 -F -q ${block_device} || return 1

        # set ext4 label; disable enforced fsck
        run_cmd tune2fs ${block_device} -c -1 -i 0 -L ${ext4_label} || return 1
        run_cmd sync

        # check filesystem again with forced mode
        run_cmd fsck.ext4  ${block_device} -f -y || return 1

        # get /dev/disk/by-label/<name> available
        run_cmd udevadm trigger -w ${block_device}
    else
        if [ ${fsck_res} -eq 2 ]; then
            # -- corrected by fsck, but reboot required --
            msg "reboot indicated by fsck"
            reboot -f
        fi
    fi

    return 0
}

# get block device name from label
#     using this functions guarantees consistent /proc/mounts
get_block_device()
{
    local label="$1"  # label designating block device
    local blk_dev=""

    # currently filesystem labels are used; TODO: use partition labels based on GPT
    blk_dev=$(readlink -f /dev/disk/by-label/${label})

    if [ -z "${blk_dev}" ] || [ ! -b "${blk_dev}" ]; then
        msg_fatal "\"${blk_dev}\" not a valid block device [label=${label}]"  # output: /dev/console
        echo ""
        return 1
    fi

    echo ${blk_dev}
    return 0
}

# mount filesystem of partition
mount_partition()
{
    local  fs_type="$1"  # filesystem type
    local  blk_dev="$2"  # block device name
    local  mnt_dir="$3"  # mount point
    local mnt_opts="$4"  # mount options

    if [ -z "${blk_dev}" ] || [ ! -b "${blk_dev}" ]; then
        msg_fatal "\"${blk_dev}\" not a valid block device"
        return 1
    fi

    run_cmd mount -t "${fs_type}" -o "${mnt_opts}" "${blk_dev} " "${mnt_dir}"
    return $?
}

# mount overlay filesystem
mount_overlayfs()
{
    local lowerdir="$1"
    local upperdir="$2"
    local  workdir="$3"
    local mnt_opts="$4"  # mount options
    local  mnt_dir="$5"  # mount point

    run_cmd mount -t overlay \
                  -o ${mnt_opts},lowerdir=${lowerdir},upperdir=${upperdir},workdir=${workdir} \
                  overlay ${mnt_dir}
}

# get value of bootloader environment variable
get_bootloader_env_var()
{
    local var_name="$1"
    fw_printenv ${var_name} | cut -d'=' -f2
}

# set/delete bootloader environment variable
set_bootloader_env_var()
{
    local  var_name="$1"
    local var_value="$2"  # empty string to delete variable
    fw_setenv ${var_name} ${var_value}
}

# if etc partition is empty, copy the etc dir from factory partition
setup_etc_from_factory()
{
    local rootfs_dir="$1"
    local    enforce="$2"

    mkdir -p ${rootfs_dir}/etc/work
    if [ ${enforce} -eq 1 ] || [ ! -d ${rootfs_dir}/etc/upper ]; then
        mkdir -p ${rootfs_dir}/etc/upper
        if [ -d ${rootfs_dir}/factory/etc ]; then
            msg "setup etc from factory partition"
            cp -rfp ${rootfs_dir}/factory/etc/. ${rootfs_dir}/etc/upper
        fi
    fi
}
