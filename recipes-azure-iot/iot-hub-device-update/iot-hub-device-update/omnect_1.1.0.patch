diff --git a/CMakeLists.txt b/CMakeLists.txt
index 15b2c9e..032175c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -200,7 +200,7 @@ set (
     ADUC_STEP_HANDLER_NAME_TO_DIRECOTRY_MAP
     "microsoft/apt,apt_handler" "microsoft/script,script_handler"
     "microsoft/simulator,simulator_handler" "microsoft/swupdate_v2,swupdate_handler_v2"
-    "microsoft/wim,wim_handler")
+    "microsoft/wim,wim_handler" "omnect/swupdate_consent_v1,swupdate_consent_handler")
 
 if (WIN32)
     set (
@@ -381,6 +381,11 @@ set (
     "syslog"
     CACHE STRING "The syslog group.")
 
+set (
+    ADUC_STORAGE_PATH
+    "/"
+    CACHE STRING "Path to mounted storage which will be considered to compute total storage")
+
 set (
     ADUC_IOT_HUB_PROTOCOL
     "IotHub_Protocol_from_Config"
diff --git a/scripts/error_code_generator_defs/result_codes.json b/scripts/error_code_generator_defs/result_codes.json
index 6fc707c..11d4e4b 100644
--- a/scripts/error_code_generator_defs/result_codes.json
+++ b/scripts/error_code_generator_defs/result_codes.json
@@ -369,6 +369,10 @@
                             "name": "ADUC_ERC_SWUPDATE_HANDLER_APPLY_FAILED_TO_GET_CONFIG_INSTANCE",
                             "value": 769
                         },
+                        {
+                            "name": "ADUC_ERC_SWUPDATE_HANDLER_INSTALL_FAILURE_VALIDATION",
+                            "value": 800
+                        },
                         {
                             "name": "ADUC_ERC_SWUPDATE_HANDLER_CANCEL_FAILURE",
                             "value": 1024
@@ -1461,4 +1465,4 @@
             "name": "ADUC_FACILITY_UNUSED_F"
         }
     ]
-}
+}
\ No newline at end of file
diff --git a/src/adu_workflow/src/agent_workflow.c b/src/adu_workflow/src/agent_workflow.c
index 3eb5fa4..f71a636 100644
--- a/src/adu_workflow/src/agent_workflow.c
+++ b/src/adu_workflow/src/agent_workflow.c
@@ -14,7 +14,9 @@
 
 #define __STDC_FORMAT_MACROS
 #include <inttypes.h> // PRIu64
+#include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 
 #include <time.h>
 
@@ -418,9 +420,31 @@ void ADUC_Workflow_HandlePropertyUpdate(
     ADUC_WorkflowData* currentWorkflowData, const unsigned char* propertyUpdateValue, bool forceUpdate)
 {
     ADUC_WorkflowHandle nextWorkflow;
+    const char omnectValidateUpdateFailedFilePath[FILENAME_MAX] =
+        "/run/omnect-device-service/omnect_validate_update_failed";
+    const char* serviceRuntimeDir = getenv("RUNTIME_DIRECTORY"); // created by deviceupdate-agent.service
+    const char* omnectUpdateRetryFileName = "/omnect_update_retry";
+    char* omnectUpdateRetryFilePath = NULL;
 
     ADUC_Result result = workflow_init((const char*)propertyUpdateValue, true /* shouldValidate */, &nextWorkflow);
 
+    if (NULL == serviceRuntimeDir)
+    {
+        Log_Error("RUNTIME_DIRECTORY was not found.");
+        return;
+    }
+
+    if (NULL
+        != (omnectUpdateRetryFilePath = malloc(strlen(serviceRuntimeDir) + strlen(omnectUpdateRetryFileName) + 1)))
+    {
+        strcpy(omnectUpdateRetryFilePath, serviceRuntimeDir);
+        strcat(omnectUpdateRetryFilePath, omnectUpdateRetryFileName);
+    }
+    else
+    {
+        Log_Error("Cannot allocate omnectUpdateRetryFilePath.");
+    }
+
     workflow_set_force_update(nextWorkflow, forceUpdate);
 
     ADUC_Result_t rootkeyErc = RootKeyUtility_GetReportingErc();
@@ -491,6 +515,21 @@ void ADUC_Workflow_HandlePropertyUpdate(
 
                 Log_Debug("Retry %s is applicable", newRetryToken);
 
+                // If omnect_validate_update_failed file barrier is present and an update retry was
+                // triggered by cloud, we create omnect_update_retry file in order to try to install
+                // the update again.
+                FILE* fp;
+
+                Log_Debug("Retry: '%s' detected.", omnectValidateUpdateFailedFilePath);
+                if ((NULL == omnectUpdateRetryFilePath) || (NULL == (fp = fopen(omnectUpdateRetryFilePath, "w"))))
+                {
+                    Log_Error("Cannot create '%s'", omnectUpdateRetryFilePath);
+                }
+                else
+                {
+                    fclose(fp);
+                }
+
                 // Sets both cancellation type to Retry and updates the current retry token
                 workflow_update_retry_deployment(currentWorkflowData->WorkflowHandle, newRetryToken);
 
@@ -971,7 +1010,6 @@ void ADUC_Workflow_WorkCompletionCallback(const void* workCompletionToken, ADUC_
                     // Reset workflow state to process deployment and transfer
                     // the deferred workflow to current.
                     workflow_update_for_replacement(workflowData->WorkflowHandle);
-
                 }
                 else
                 {
diff --git a/src/communication_managers/iothub_communication_manager/CMakeLists.txt b/src/communication_managers/iothub_communication_manager/CMakeLists.txt
index 9707b06..5f47727 100644
--- a/src/communication_managers/iothub_communication_manager/CMakeLists.txt
+++ b/src/communication_managers/iothub_communication_manager/CMakeLists.txt
@@ -29,7 +29,8 @@ target_link_libraries (
             aduc::eis_utils
             aduc::logging
             aduc::retry_utils
-            aduc::url_utils)
+            aduc::url_utils
+            systemd)
 
 target_link_libraries (${target_name} PRIVATE libaducpal)
 
diff --git a/src/communication_managers/iothub_communication_manager/src/iothub_communication_manager.c b/src/communication_managers/iothub_communication_manager/src/iothub_communication_manager.c
index 6397fea..c7c1bae 100644
--- a/src/communication_managers/iothub_communication_manager/src/iothub_communication_manager.c
+++ b/src/communication_managers/iothub_communication_manager/src/iothub_communication_manager.c
@@ -39,6 +39,8 @@
 #include <stdlib.h> // strtol
 #include <sys/stat.h>
 
+#include <systemd/sd-daemon.h>
+
 /**
  * @brief A pointer to ADUC_ClientHandle data. This must be initialize by the component that creates the IoT Hub connection.
  */
@@ -59,6 +61,11 @@ static IOTHUB_CLIENT_DEVICE_TWIN_CALLBACK g_device_twin_callback = NULL;
  */
 static bool g_iothub_client_initialized = false;
 
+/**
+ * @brief A boolean indicates whether the IoT Hub client was once authenticated to iothub.
+ */
+static bool g_iothub_client_authenticated_once = false;
+
 /**
  * @brief An additional data context used the caller.
  */
@@ -215,6 +222,11 @@ void IoTHub_CommunicationManager_ConnectionStatus_Callback(
     case IOTHUB_CLIENT_CONNECTION_AUTHENTICATED:
         g_last_authenticated_time = now_time;
         g_authentication_retries = 0;
+        if (false == g_iothub_client_authenticated_once)
+        {
+            sd_notify(0, "READY=1");
+            g_iothub_client_authenticated_once = true;
+        }
         break;
     case IOTHUB_CLIENT_CONNECTION_UNAUTHENTICATED:
         if (g_last_authenticated_time >= g_first_unauthenticated_time)
diff --git a/src/diagnostics_component/diagnostics_workflow/CMakeLists.txt b/src/diagnostics_component/diagnostics_workflow/CMakeLists.txt
index 8500827..71b9cec 100644
--- a/src/diagnostics_component/diagnostics_workflow/CMakeLists.txt
+++ b/src/diagnostics_component/diagnostics_workflow/CMakeLists.txt
@@ -16,7 +16,7 @@ find_package (Parson REQUIRED)
 target_link_aziotsharedutil (${target_name} PRIVATE)
 
 if (NOT WIN32)
-    target_link_libraries (${target_name} PRIVATE diagnostic_utils::file_upload_utility)
+#     target_link_libraries (${target_name} PRIVATE diagnostic_utils::file_upload_utility)
 endif ()
 
 target_link_libraries (
diff --git a/src/diagnostics_component/diagnostics_workflow/src/diagnostics_workflow.c b/src/diagnostics_component/diagnostics_workflow/src/diagnostics_workflow.c
index 5c232a1..8751a29 100644
--- a/src/diagnostics_component/diagnostics_workflow/src/diagnostics_workflow.c
+++ b/src/diagnostics_component/diagnostics_workflow/src/diagnostics_workflow.c
@@ -11,7 +11,7 @@
 #include <aduc/logging.h>
 #include <aduc/string_c_utils.h>
 
-#if defined(_WIN32)
+// #if defined(_WIN32)
 typedef struct tagBlobStorageInfo
 {
     STRING_HANDLE virtualDirectoryPath; //!< Virtual hierarchy for the blobs
@@ -27,9 +27,9 @@ static bool FileUploadUtility_UploadFilesToContainer(
 
     return false;
 }
-#else
-#    include <file_upload_utility.h>
-#endif
+// #else
+// #    include <file_upload_utility.h>
+// #endif
 
 #include <diagnostics_config_utils.h>
 #include <diagnostics_devicename.h>
diff --git a/src/diagnostics_component/utils/CMakeLists.txt b/src/diagnostics_component/utils/CMakeLists.txt
index 2952f34..811a22f 100644
--- a/src/diagnostics_component/utils/CMakeLists.txt
+++ b/src/diagnostics_component/utils/CMakeLists.txt
@@ -2,5 +2,5 @@ cmake_minimum_required (VERSION 3.5)
 
 add_subdirectory (config_utils)
 add_subdirectory (file_info_utils)
-add_subdirectory (file_upload_utils)
+# add_subdirectory (file_upload_utils)
 add_subdirectory (operation_id_utils)
diff --git a/src/extensions/CMakeLists.txt b/src/extensions/CMakeLists.txt
index e7bcad3..65e9225 100644
--- a/src/extensions/CMakeLists.txt
+++ b/src/extensions/CMakeLists.txt
@@ -1,6 +1,6 @@
 add_subdirectory (content_downloaders)
 if (NOT WIN32)
-    add_subdirectory (component_enumerators/examples/contoso_component_enumerator)
+#     add_subdirectory (component_enumerators/examples/contoso_component_enumerator)
 endif ()
 add_subdirectory (download_handlers)
 add_subdirectory (extension_manager)
diff --git a/src/extensions/content_downloaders/CMakeLists.txt b/src/extensions/content_downloaders/CMakeLists.txt
index d9978f0..69b3c4a 100644
--- a/src/extensions/content_downloaders/CMakeLists.txt
+++ b/src/extensions/content_downloaders/CMakeLists.txt
@@ -1,4 +1,4 @@
 cmake_minimum_required (VERSION 3.5)
 
-add_subdirectory (curl_downloader)
+# add_subdirectory (curl_downloader)
 add_subdirectory (deliveryoptimization_downloader)
diff --git a/src/extensions/download_handlers/CMakeLists.txt b/src/extensions/download_handlers/CMakeLists.txt
index 850c103..bc0bb06 100644
--- a/src/extensions/download_handlers/CMakeLists.txt
+++ b/src/extensions/download_handlers/CMakeLists.txt
@@ -1,3 +1,3 @@
 add_subdirectory (download_handler_factory)
 add_subdirectory (download_handler_plugin)
-add_subdirectory (plugin_examples)
+# add_subdirectory (plugin_examples)
diff --git a/src/extensions/step_handlers/swupdate_consent_handler/CMakeLists.txt b/src/extensions/step_handlers/swupdate_consent_handler/CMakeLists.txt
new file mode 100644
index 0000000..3f9afef
--- /dev/null
+++ b/src/extensions/step_handlers/swupdate_consent_handler/CMakeLists.txt
@@ -0,0 +1,41 @@
+cmake_minimum_required (VERSION 3.5)
+
+set (target_name omnect_swupdate_consent_1)
+
+set (SOURCE_ALL src/swupdate_consent_handler.cpp)
+
+
+add_library (${target_name} MODULE)
+
+add_library (aduc::${target_name} ALIAS ${target_name})
+
+find_package (Parson REQUIRED)
+
+target_sources (${target_name} PRIVATE src/swupdate_consent_handler.cpp)
+
+target_include_directories (
+    ${target_name}
+    PUBLIC inc
+    PRIVATE ${PROJECT_SOURCE_DIR}/inc
+            ${ADUC_TYPES_INCLUDES}
+            ${ADUC_EXPORT_INCLUDES}
+            ${ADU_SHELL_INCLUDES}
+            ${ADU_EXTENSION_INCLUDES})
+
+find_package (azure_c_shared_utility REQUIRED)
+
+target_link_libraries (
+    ${target_name}
+    PRIVATE aduc::contract_utils
+            aduc::logging
+            aduc::agent_workflow
+            aduc::workflow_utils
+            aduc::string_utils
+            Parson::parson
+            )
+
+target_compile_definitions (
+    ${target_name}
+    PRIVATE ADUC_VERSION_FILE="${ADUC_VERSION_FILE}")
+
+install (TARGETS ${target_name} LIBRARY DESTINATION ${ADUC_EXTENSIONS_INSTALL_FOLDER})
diff --git a/src/extensions/step_handlers/swupdate_consent_handler/files/consent_conf.json b/src/extensions/step_handlers/swupdate_consent_handler/files/consent_conf.json
new file mode 100644
index 0000000..69f9ca4
--- /dev/null
+++ b/src/extensions/step_handlers/swupdate_consent_handler/files/consent_conf.json
@@ -0,0 +1,5 @@
+{
+  "general_consent": [
+    "swupdate"
+  ]
+}
\ No newline at end of file
diff --git a/src/extensions/step_handlers/swupdate_consent_handler/files/history_consent.json b/src/extensions/step_handlers/swupdate_consent_handler/files/history_consent.json
new file mode 100644
index 0000000..698c790
--- /dev/null
+++ b/src/extensions/step_handlers/swupdate_consent_handler/files/history_consent.json
@@ -0,0 +1,6 @@
+{
+  "user_consent_history": {
+      "swupdate": [
+      ]
+  }
+}
\ No newline at end of file
diff --git a/src/extensions/step_handlers/swupdate_consent_handler/files/request_consent.json b/src/extensions/step_handlers/swupdate_consent_handler/files/request_consent.json
new file mode 100644
index 0000000..9f35e52
--- /dev/null
+++ b/src/extensions/step_handlers/swupdate_consent_handler/files/request_consent.json
@@ -0,0 +1,4 @@
+{
+  "user_consent_request": [
+  ]
+}
\ No newline at end of file
diff --git a/src/extensions/step_handlers/swupdate_consent_handler/files/user_consent.json b/src/extensions/step_handlers/swupdate_consent_handler/files/user_consent.json
new file mode 100644
index 0000000..0e0dcd2
--- /dev/null
+++ b/src/extensions/step_handlers/swupdate_consent_handler/files/user_consent.json
@@ -0,0 +1,3 @@
+{
+
+}
\ No newline at end of file
diff --git a/src/extensions/step_handlers/swupdate_consent_handler/inc/aduc/swupdate_consent_handler.hpp b/src/extensions/step_handlers/swupdate_consent_handler/inc/aduc/swupdate_consent_handler.hpp
new file mode 100644
index 0000000..8ea0cf2
--- /dev/null
+++ b/src/extensions/step_handlers/swupdate_consent_handler/inc/aduc/swupdate_consent_handler.hpp
@@ -0,0 +1,73 @@
+/**
+ * @file swupdate_consent_handler.hpp
+ * @brief Defines SWUpdateConsentHandlerImpl.
+ *
+ * @copyright Copyright (c) conplement AG.
+ * Licensed under either of Apache-2.0 or MIT license at your option.
+ */
+#ifndef ADUC_SWUPDATECONSENT_HANDLER_HPP
+#define ADUC_SWUPDATECONSENT_HANDLER_HPP
+
+#include <string>
+
+#include "aduc/content_handler.hpp"
+#include "aduc/logging.h"
+#include <parson.h>
+
+
+EXTERN_C_BEGIN
+
+/**
+ * @brief Instantiates an Update Content Handler swupdateconsent.
+ * @return A pointer to an instantiated Update Content Handler object.
+ */
+ContentHandler* CreateUpdateContentHandlerExtension(ADUC_LOG_SEVERITY logLevel);
+
+EXTERN_C_END
+
+/**
+ * @class SWUpdateConsentHandlerImpl
+ * @brief The swupdateconsent handler implementation.
+ */
+class SWUpdateConsentHandlerImpl : public ContentHandler
+{
+public:
+    static ContentHandler* CreateContentHandler();
+
+    // Delete copy ctor, copy assignment, move ctor and move assignment operators.
+    SWUpdateConsentHandlerImpl(const SWUpdateConsentHandlerImpl&) = delete;
+    SWUpdateConsentHandlerImpl& operator=(const SWUpdateConsentHandlerImpl&) = delete;
+    SWUpdateConsentHandlerImpl(SWUpdateConsentHandlerImpl&&) = delete;
+    SWUpdateConsentHandlerImpl& operator=(SWUpdateConsentHandlerImpl&&) = delete;
+
+    ~SWUpdateConsentHandlerImpl() override;
+
+    ADUC_Result Download(const tagADUC_WorkflowData* workflowData) override;
+    ADUC_Result Backup(const tagADUC_WorkflowData* workflowData) override;
+    ADUC_Result Install(const tagADUC_WorkflowData* workflowData) override;
+    ADUC_Result Apply(const tagADUC_WorkflowData* workflowData) override;
+    ADUC_Result Restore(const tagADUC_WorkflowData* workflowData) override;
+    ADUC_Result Cancel(const tagADUC_WorkflowData* workflowData) override;
+    ADUC_Result IsInstalled(const tagADUC_WorkflowData* workflowData) override;
+
+private:
+    const std::string generalConsent = "swupdate";
+
+    // Private constructor, must call CreateContentHandler factory method.
+    SWUpdateConsentHandlerImpl()
+    {
+    }
+    std::string ValueOrEmpty(const char* s);
+    std::string ReadValueFromFile(const std::string& filePath);
+    JSON_Object* ReadJsonDataFile(const std::string& filePath);
+    bool GetGeneralConsent(void);
+    ADUC_GeneralResult CleanUserConsentAgreed(void);
+    bool UserConsentAgreed(const std::string& version);
+    bool AppendArrayRecord(const JSON_Object* root, const char* arrayName, JSON_Value* record);
+    ADUC_GeneralResult UpdateConsentRequestJsonFile(const std::string& version);
+    ADUC_GeneralResult CleanConsentRequestJsonFile(void);
+    ADUC_GeneralResult UpdateConsentHistoryJsonFile(const std::string& version);
+    std::string GetVersion(const std::string& installedCriteria);
+};
+
+#endif // ADUC_SWUPDATECONSENT_HANDLER_HPP
diff --git a/src/extensions/step_handlers/swupdate_consent_handler/src/swupdate_consent_handler.cpp b/src/extensions/step_handlers/swupdate_consent_handler/src/swupdate_consent_handler.cpp
new file mode 100644
index 0000000..891e09b
--- /dev/null
+++ b/src/extensions/step_handlers/swupdate_consent_handler/src/swupdate_consent_handler.cpp
@@ -0,0 +1,599 @@
+/**
+ * @file swupdate_consent_handler.cpp
+ * @brief Implementation of ContentHandler API for update content swupdate_consent.
+ *
+ * @copyright Copyright (c) conplement AG.
+ * Licensed under either of Apache-2.0 or MIT license at your option.
+ */
+#include <fstream>
+
+#include "aduc/logging.h"
+#include "aduc/string_c_utils.h"
+#include "aduc/string_utils.hpp"
+#include "aduc/swupdate_consent_handler.hpp"
+#include "aduc/workflow_utils.h"
+#include <azure_c_shared_utility/threadapi.h> // ThreadAPI_Sleep
+#include <parson.h>
+#include <signal.h> // raise()
+
+#define ADUC_SWUPDATE_CONSENT_CONF_FILE "/etc/omnect/consent/consent_conf.json"
+#define ADUC_SWUPDATE_CONSENT_USER_FILE "/etc/omnect/consent/swupdate/user_consent.json"
+#define ADUC_SWUPDATE_CONSENT_REQUEST_FILE "/etc/omnect/consent/request_consent.json"
+#define ADUC_SWUPDATE_CONSENT_HISTORY_FILE "/etc/omnect/consent/history_consent.json"
+
+EXTERN_C_BEGIN
+
+/////////////////////////////////////////////////////////////////////////////
+// BEGIN Shared Library Export Functions
+//
+// These are the function symbols that the device update agent will
+// lookup and call.
+//
+
+/**
+ * @brief Instantiates an SWUpdateConsent Update Content Handler
+ */
+ContentHandler* CreateUpdateContentHandlerExtension(ADUC_LOG_SEVERITY logLevel)
+{
+    ADUC_Logging_Init(logLevel, "swupdate_consent-handler");
+    Log_Info("Instantiating a SWUpdateConsent Update Content Handler");
+    try
+    {
+        return SWUpdateConsentHandlerImpl::CreateContentHandler();
+    }
+    catch (const std::exception& e)
+    {
+        const char* what = e.what();
+        Log_Error("Unhandled std exception: %s", what);
+    }
+    catch (...)
+    {
+        Log_Error("Unhandled exception");
+    }
+
+    return nullptr;
+}
+
+/**
+ * @brief Gets the extension contract info.
+ *
+ * @param[out] contractInfo The extension contract info.
+ * @return ADUC_Result The result.
+ */
+ADUC_Result GetContractInfo(ADUC_ExtensionContractInfo* contractInfo)
+{
+    contractInfo->majorVer = ADUC_V1_CONTRACT_MAJOR_VER;
+    contractInfo->minorVer = ADUC_V1_CONTRACT_MINOR_VER;
+    return ADUC_Result{ ADUC_GeneralResult_Success, 0 };
+}
+
+//
+// END Shared Library Export Functions
+/////////////////////////////////////////////////////////////////////////////
+
+EXTERN_C_END
+
+/**
+ * @brief Destructor for the SWUpdateConsent Handler Impl class.
+ */
+SWUpdateConsentHandlerImpl::~SWUpdateConsentHandlerImpl() // override
+{
+    ADUC_Logging_Uninit();
+}
+
+/**
+ * @brief Creates a new SWUpdateConsentHandlerImpl object and casts to a ContentHandler.
+ * Note that there is no way to create a SWUpdateConsentHandlerImpl directly.
+ *
+ * @return ContentHandler* SWUpdateConsentHandlerImpl object as a ContentHandler.
+ */
+ContentHandler* SWUpdateConsentHandlerImpl::CreateContentHandler()
+{
+    return new SWUpdateConsentHandlerImpl();
+}
+
+/**
+ * @brief Convert char pointer to string
+ *
+ * @param s Pointer to char
+ * @return std::string Returns the value from char pointer. Returns empty string if there was an error.
+ */
+std::string SWUpdateConsentHandlerImpl::ValueOrEmpty(const char* s)
+{
+    return s == nullptr ? std::string() : s;
+}
+
+/**
+ * @brief Reads a first line of a file, trims trailing whitespace, and returns as string.
+ *
+ * @param filePath Path to the file to read value from.
+ * @return std::string Returns the value from the file. Returns empty string if there was an error.
+ */
+std::string SWUpdateConsentHandlerImpl::ReadValueFromFile(const std::string& filePath)
+{
+    if (filePath.empty())
+    {
+        Log_Error("Empty file path.");
+        return "";
+    }
+
+    if ((filePath.length()) + 1 > PATH_MAX)
+    {
+        Log_Error("Path is too long.");
+        return "";
+    }
+
+    std::ifstream file(filePath);
+    if (!file.is_open())
+    {
+        Log_Error("File %s failed to open, error: %d", filePath.c_str(), errno);
+        return "";
+    }
+
+    std::string result;
+    std::getline(file, result);
+    if (file.bad())
+    {
+        Log_Error("Unable to read from file %s, error: %d", filePath.c_str(), errno);
+        return "";
+    }
+
+    // Trim whitespace
+    ADUC::StringUtils::Trim(result);
+    return result;
+}
+
+/**
+ * @brief Load data from given path.
+ *
+ * @param filePath Path to the file to read value from.
+ * @return JSON_Object A json object containing data.
+ *         Caller must free the wrapping JSON_Value* object to free the memory.
+ */
+JSON_Object* SWUpdateConsentHandlerImpl::ReadJsonDataFile(const std::string& filePath)
+{
+    JSON_Value* rootValue = json_parse_file(filePath.c_str());
+
+    if (nullptr == rootValue)
+    {
+        Log_Error("Cannot read file: %s", filePath);
+    }
+    return json_value_get_object(rootValue);
+}
+
+/**
+ * @brief Check general consent from configuration consent file.
+ *
+ * @return "true" in case general consent is agreed, otherwise "false" will be returned
+ */
+bool SWUpdateConsentHandlerImpl::GetGeneralConsent(void)
+{
+    bool status = false;
+    JSON_Object* data = ReadJsonDataFile(ADUC_SWUPDATE_CONSENT_CONF_FILE);
+
+    if (nullptr == data)
+    {
+        Log_Error("No ADUC_SWUPDATE_CONSENT_CONF_FILE data file provided, or missing json content");
+    }
+    else
+    {
+        JSON_Array* array = json_object_get_array(data, "general_consent");
+        if (nullptr == array)
+        {
+            Log_Error("general_consent not found in ADUC_SWUPDATE_CONSENT_CONF_FILE data file");
+        }
+        else
+        {
+            for (int i = 0; i < json_array_get_count(array); i++)
+            {
+                std::string generalConsentStatus = ValueOrEmpty(json_array_get_string(array, i));
+                Log_Info("parsing json array genenral_consent: %s \n", generalConsentStatus.c_str());
+
+                if (generalConsent == generalConsentStatus)
+                {
+                    Log_Info("genenral_consent found for swupdate\n");
+                    status = true;
+                    break;
+                }
+            }
+        }
+        json_value_free(json_object_get_wrapping_value(data));
+    }
+
+    return status;
+}
+
+/**
+ * @brief Verifys that consent has been granted
+ *
+ * @param version Version to compare with the user consent version
+ * @return "true" in case user consent is agreed, otherwise "false" will be returned
+ *
+ */
+bool SWUpdateConsentHandlerImpl::UserConsentAgreed(const std::string& version)
+{
+    bool status = false;
+    JSON_Object* data = ReadJsonDataFile(ADUC_SWUPDATE_CONSENT_USER_FILE);
+
+    if (nullptr == data)
+    {
+        Log_Error("No ADUC_SWUPDATE_CONSENT_USER_FILE data file provided, or missing json content");
+    }
+    else
+    {
+        std::string userConsent = ValueOrEmpty(json_object_get_string(data, "consent"));
+        if (userConsent == version)
+        {
+            status = true;
+        }
+        json_value_free(json_object_get_wrapping_value(data));
+    }
+    return status;
+}
+
+/**
+ * @brief Clean user consent agreed
+ *
+ * @return ADUC_GeneralResult
+ *
+ */
+ADUC_GeneralResult SWUpdateConsentHandlerImpl::CleanUserConsentAgreed(void)
+{
+    ADUC_GeneralResult result = ADUC_GeneralResult_Failure;
+    JSON_Value* rootValue = json_parse_file(ADUC_SWUPDATE_CONSENT_USER_FILE);
+    JSON_Object* data = json_value_get_object(rootValue);
+
+    Log_Info("clean user consent agreed");
+
+    if (nullptr == data)
+    {
+        Log_Error("No ADUC_SWUPDATE_CONSENT_USER_FILE data file provided, or missing json content");
+    }
+    else
+    {
+        // clean ADUC_SWUPDATE_CONSENT_USER_FILE only if consent available -> prevent file write operation
+        if (json_object_has_value(data, "consent") != 0)
+        {
+            Log_Info("clean ADUC_SWUPDATE_CONSENT_USER_FILE");
+            json_object_remove(data, "consent");
+            json_serialize_to_file_pretty(rootValue, ADUC_SWUPDATE_CONSENT_USER_FILE);
+        }
+        result = ADUC_GeneralResult_Success;
+        json_value_free(rootValue);
+    }
+
+    return result;
+}
+
+/**
+ * @brief add records to an json array
+ *
+ * @param root  root of the parsed file
+ * @param arrayName  the value name can be hierarchical as a dot separated string.
+ * @param record  record to add
+ * @return "true" in case successfully, otherwise "false" will be returned
+ *
+ */
+bool SWUpdateConsentHandlerImpl::AppendArrayRecord(const JSON_Object* root, const char* arrayName, JSON_Value* record)
+{
+    bool result = false;
+    JSON_Array* array;
+
+    array = json_object_dotget_array(root, arrayName);
+
+    if (json_array_append_value(array, record) == JSONSuccess)
+    {
+        result = true;
+    }
+
+    return result;
+}
+
+/**
+ * @brief Request a user consent for given version
+ *
+ * @param version Version for request a user consent
+ * @return ADUC_GeneralResult
+ *
+ */
+ADUC_GeneralResult SWUpdateConsentHandlerImpl::UpdateConsentRequestJsonFile(const std::string& version)
+{
+    ADUC_GeneralResult result = ADUC_GeneralResult_Failure;
+    JSON_Value* rootValue = json_parse_file(ADUC_SWUPDATE_CONSENT_REQUEST_FILE);
+    JSON_Object* data = json_value_get_object(rootValue);
+
+    if (nullptr == data)
+    {
+        Log_Error("No ADUC_SWUPDATE_CONSENT_REQUEST_FILE data file provided");
+    }
+    else
+    {
+        JSON_Array* array = json_object_get_array(data, "user_consent_request");
+        if (nullptr == array)
+        {
+            Log_Error("No user_consent_request in ADUC_SWUPDATE_CONSENT_REQUEST_FILE data file provided");
+        }
+        else
+        {
+            JSON_Value* swupdateValue = json_value_init_object();
+            JSON_Object* swupdateObject = json_value_get_object(swupdateValue);
+            json_object_set_string(swupdateObject, "swupdate", version.c_str());
+            if (true == AppendArrayRecord(data, "user_consent_request", swupdateValue))
+            {
+                json_serialize_to_file_pretty(rootValue, ADUC_SWUPDATE_CONSENT_REQUEST_FILE);
+                result = ADUC_GeneralResult_Success;
+            }
+            else
+            {
+                Log_Error("append to user_consent_request in ADUC_SWUPDATE_CONSENT_REQUEST_FILE not working");
+            }
+        }
+        json_value_free(rootValue);
+    }
+
+    return result;
+}
+
+/**
+ * @brief Clean request user consent
+ *
+ * @return ADUC_GeneralResult
+ *
+ */
+ADUC_GeneralResult SWUpdateConsentHandlerImpl::CleanConsentRequestJsonFile(void)
+{
+    ADUC_GeneralResult result = ADUC_GeneralResult_Failure;
+    JSON_Value* rootValue = json_parse_file(ADUC_SWUPDATE_CONSENT_REQUEST_FILE);
+    JSON_Object* data = json_value_get_object(rootValue);
+
+    Log_Info("clean consent request");
+
+    if (nullptr == data)
+    {
+        Log_Error("No ADUC_SWUPDATE_CONSENT_REQUEST_FILE data file provided");
+    }
+    else
+    {
+        JSON_Array* array = json_object_get_array(data, "user_consent_request");
+        if (nullptr == array)
+        {
+            Log_Error("No user_consent_request in ADUC_SWUPDATE_CONSENT_REQUEST_FILE data file provided");
+        }
+        else
+        {
+            // clean ADUC_SWUPDATE_CONSENT_REQUEST_FILE only if array is not empty -> prevent file write operation
+            if (json_array_get_count(array) != 0)
+            {
+                Log_Info("clean ADUC_SWUPDATE_CONSENT_REQUEST_FILE");
+                json_array_clear(array);
+                json_serialize_to_file_pretty(rootValue, ADUC_SWUPDATE_CONSENT_REQUEST_FILE);
+            }
+            result = ADUC_GeneralResult_Success;
+        }
+        json_value_free(rootValue);
+    }
+
+    return result;
+}
+
+/**
+ * @brief store user consent version in history file
+ *
+ * @param version user consent version
+ * @return ADUC_GeneralResult
+ *
+ */
+ADUC_GeneralResult SWUpdateConsentHandlerImpl::UpdateConsentHistoryJsonFile(const std::string& version)
+{
+    ADUC_GeneralResult result = ADUC_GeneralResult_Failure;
+    JSON_Value* rootValue = json_parse_file(ADUC_SWUPDATE_CONSENT_HISTORY_FILE);
+    JSON_Object* data = json_value_get_object(rootValue);
+
+    if (nullptr == data)
+    {
+        Log_Error("No ADUC_SWUPDATE_CONSENT_HISTORY_FILE data file provided");
+    }
+    else
+    {
+        JSON_Object* data2 = json_object_get_object(data, "user_consent_history");
+        if (nullptr == data2)
+        {
+            Log_Error("No user_consent_agreed object in ADUC_SWUPDATE_CONSENT_HISTORY_FILE data file provided");
+        }
+        else
+        {
+            JSON_Array* array = json_object_get_array(data2, "swupdate");
+            if (nullptr == array)
+            {
+                Log_Error("No swupdate array in ADUC_SWUPDATE_CONSENT_HISTORY_FILE data file provided");
+            }
+            else
+            {
+                json_array_append_string(array, version.c_str());
+                json_serialize_to_file_pretty(rootValue, ADUC_SWUPDATE_CONSENT_HISTORY_FILE);
+                result = ADUC_GeneralResult_Success;
+            }
+        }
+        json_value_free(rootValue);
+    }
+
+    return result;
+}
+
+/**
+ * @brief get version from installed criteria
+ *
+ * @param installedCriteria installed criteria info
+ * @return std::string Returns the version from given installed criteria. Returns empty string if there was an error.
+ *
+ */
+std::string SWUpdateConsentHandlerImpl::GetVersion(const std::string& installedCriteria)
+{
+    std::string version(strchr(installedCriteria.c_str(), ' '));
+
+    if (version.empty())
+    {
+        Log_Error("couldn't read version from installedCriteria");
+        return "";
+    }
+    else
+    {
+        Log_Info("read version \"%s\" from installedCriteria", version.c_str());
+        // Trim whitespace
+        ADUC::StringUtils::Trim(version);
+        return version;
+    }
+}
+
+/**
+ * @brief Implementation of download action.
+ * @return ADUC_Result return ADUC_Result_Download_Success.
+ */
+ADUC_Result SWUpdateConsentHandlerImpl::Download(const tagADUC_WorkflowData* workflowData)
+{
+    bool consent = false;
+    ADUC_WorkflowHandle workflowHandle = workflowData->WorkflowHandle;
+    char* installedCriteria_workflow = workflow_get_installed_criteria(workflowData->WorkflowHandle);
+    std::string installedCriteria = ValueOrEmpty(installedCriteria_workflow);
+    std::string version = GetVersion(installedCriteria);
+
+    Log_Info("swupdate waiting for user consent");
+
+    // cleanup request JSON file to prevent duplicate information in array due to e.g. device reboot
+    CleanConsentRequestJsonFile();
+
+    // log message already present in function, return value currently not needed to evaluate
+    UpdateConsentRequestJsonFile(version);
+
+    while (false == consent)
+    {
+        // check if general user consent agreed
+        if (false == GetGeneralConsent())
+        {
+            if (workflow_is_cancel_requested(workflowHandle))
+            {
+                // see issue: https://github.com/Azure/iot-hub-device-update/issues/511
+                // Workaround until we get a final fix from MS
+                Log_Info("Restarting ADU Agent due to cancel request!");
+                raise(SIGUSR1);
+            }
+
+            if (true == UserConsentAgreed(version))
+            {
+                // log message already present in function, return value currently not needed to evaluate
+                UpdateConsentHistoryJsonFile(version);
+                consent = true;
+            }
+        }
+        else
+            consent = true;
+
+        // 1s timeout
+        ThreadAPI_Sleep(1000);
+    }
+
+    CleanConsentRequestJsonFile();
+    Log_Info("swupdate user consent succeeded");
+
+    workflow_free_string(installedCriteria_workflow);
+    return ADUC_Result{ ADUC_Result_Download_Success };
+}
+
+/**
+ * @brief Implementation of install
+ * @return ADUC_Result return ADUC_Result_Install_Success.
+ */
+ADUC_Result SWUpdateConsentHandlerImpl::Install(const tagADUC_WorkflowData* workflowData)
+{
+    Log_Info("SWUpdate consent doesn't require a specific operation to install. (no-op) ");
+    UNREFERENCED_PARAMETER(workflowData);
+    return ADUC_Result{ ADUC_Result_Install_Success };
+}
+
+/**
+ * @brief Implementation of apply.
+ * @return ADUC_Result return ADUC_Result_Apply_Success.
+ */
+ADUC_Result SWUpdateConsentHandlerImpl::Apply(const tagADUC_WorkflowData* workflowData)
+{
+    Log_Info("SWUpdate consent doesn't require a specific operation to apply. (no-op) ");
+    UNREFERENCED_PARAMETER(workflowData);
+    return ADUC_Result{ ADUC_Result_Apply_Success };
+}
+
+/**
+ * @brief Implementation of cancel
+ * @return ADUC_Result return ADUC_Result_Cancel_Success.
+ */
+ADUC_Result SWUpdateConsentHandlerImpl::Cancel(const tagADUC_WorkflowData* workflowData)
+{
+    Log_Info("SWUpdate consent doesn't require a specific operation to cancel. (no-op) ");
+    UNREFERENCED_PARAMETER(workflowData);
+    return ADUC_Result{ ADUC_Result_Cancel_Success };
+}
+
+/**
+ * @brief Implementation of IsInstalled check.
+ * @return ADUC_Result The result based on evaluating the installed criteria an GeneralConsent.
+ */
+ADUC_Result SWUpdateConsentHandlerImpl::IsInstalled(const tagADUC_WorkflowData* workflowData)
+{
+    ADUC_Result result = { ADUC_Result_IsInstalled_NotInstalled };
+    char* installedCriteria_workflow = workflow_get_installed_criteria(workflowData->WorkflowHandle);
+    std::string installedCriteria = ValueOrEmpty(installedCriteria_workflow);
+    std::string version = ReadValueFromFile(ADUC_VERSION_FILE);
+
+    if (true == GetGeneralConsent())
+    {
+        Log_Info("consent for swupdate is available in configuration file");
+        CleanUserConsentAgreed();
+        CleanConsentRequestJsonFile();
+        result = { ADUC_Result_IsInstalled_Installed };
+    }
+    else if (version == installedCriteria)
+    {
+        Log_Info("swupdate consent for Installed criteria %s was installed", installedCriteria.c_str());
+        CleanConsentRequestJsonFile();
+        result = { ADUC_Result_IsInstalled_Installed };
+    }
+    else
+    {
+        Log_Info(
+            "swupdate consent Installed criteria %s was not installed, the current criteria is %s",
+            installedCriteria.c_str(),
+            version.c_str());
+    }
+    workflow_free_string(installedCriteria_workflow);
+    return result;
+}
+
+/**
+ * @brief Backup implementation.
+ * Calls into the swupdate wrapper script to perform backup.
+ * For swupdate, no operation is required.
+ *
+ * @return ADUC_Result The result of the backup.
+ * It will always return ADUC_Result_Backup_Success.
+ */
+ADUC_Result SWUpdateConsentHandlerImpl::Backup(const tagADUC_WorkflowData* workflowData)
+{
+    UNREFERENCED_PARAMETER(workflowData);
+    ADUC_Result result = { ADUC_Result_Backup_Success };
+    Log_Info("SWUpdate consent doesn't require a specific operation to backup. (no-op) ");
+    return result;
+}
+
+/**
+ * @brief Restore implementation.
+ * Calls into the swupdate wrapper script to perform restore.
+ * Will flip bootloader flag to boot into the previous partition for A/B update.
+ *
+ * @return ADUC_Result The result of the restore.
+ */
+ADUC_Result SWUpdateConsentHandlerImpl::Restore(const tagADUC_WorkflowData* workflowData)
+{
+    Log_Info("SWUpdate consent doesn't require a specific operation to restore. (no-op) ");
+    UNREFERENCED_PARAMETER(workflowData);
+    ADUC_Result result = { ADUC_Result_Restore_Success };
+    return result;
+}
diff --git a/src/extensions/step_handlers/swupdate_handler_v2/src/swupdate_handler_v2.cpp b/src/extensions/step_handlers/swupdate_handler_v2/src/swupdate_handler_v2.cpp
index 2d60fa7..bc5b92c 100644
--- a/src/extensions/step_handlers/swupdate_handler_v2/src/swupdate_handler_v2.cpp
+++ b/src/extensions/step_handlers/swupdate_handler_v2/src/swupdate_handler_v2.cpp
@@ -332,12 +332,43 @@ ADUC_Result SWUpdateHandlerImpl::Download(const tagADUC_WorkflowData* workflowDa
     memset(&fileEntity, 0, sizeof(fileEntity));
     size_t fileCount = workflow_get_update_files_count(workflowHandle);
     ADUC_Result result = SWUpdate_Handler_DownloadScriptFile(workflowHandle);
+    bool retry = false;
+    std::ifstream omnectValidateUpdateFailedFilePath("/run/omnect-device-service/omnect_validate_update_failed");
+    const char* runtimeDir = std::getenv("RUNTIME_DIRECTORY");
+    std::string omnectUpdateRetryFileName("/omnect_update_retry");
 
     if (IsAducResultCodeFailure(result.ResultCode))
     {
         goto done;
     }
 
+    if (NULL == runtimeDir)
+    {
+        Log_Error("Update validation on new boot part failed. Rebooted to old boot part.");
+    }
+    else
+    {
+        std::ifstream omnectUpdateRetryFilePath(std::string(runtimeDir) + omnectUpdateRetryFileName);
+        retry = omnectUpdateRetryFilePath.good();
+    }
+
+    // We return with an error in case we just booted into here after an update validation
+    // failed on the new partition. We do this in order to step into update failed state
+    // which also shows up in ADU cloud and offers triggering an update retry.
+    // If the cloud triggered a retry we ignore omnect_validate_update_failed flag.
+    if (omnectValidateUpdateFailedFilePath.good())
+    {
+        if (!retry)
+        {
+            result = { ADUC_Result_Failure };
+            Log_Error("Update validation on new boot part failed. Rebooted to old boot part.");
+            result.ExtendedResultCode = ADUC_ERC_SWUPDATE_HANDLER_INSTALL_FAILURE_VALIDATION;
+            goto done;
+        }
+
+        Log_Info("Retry update after failed update vailidation.");
+    }
+
     // Determine whether to continue downloading the rest.
     installedCriteria = workflow_get_installed_criteria(workflowData->WorkflowHandle);
     result = IsInstalled(workflowData);
diff --git a/src/platform_layers/linux_platform_layer/CMakeLists.txt b/src/platform_layers/linux_platform_layer/CMakeLists.txt
index 40d57d1..000e530 100644
--- a/src/platform_layers/linux_platform_layer/CMakeLists.txt
+++ b/src/platform_layers/linux_platform_layer/CMakeLists.txt
@@ -47,7 +47,8 @@ target_compile_definitions (
             ADUC_DEVICEINFO_MODEL="${ADUC_DEVICEINFO_MODEL}"
             ADUC_FILE_GROUP="${ADUC_FILE_GROUP}"
             ADUC_FILE_USER="${ADUC_FILE_USER}"
-            ADUC_VERSION_FILE="${ADUC_VERSION_FILE}")
+            ADUC_VERSION_FILE="${ADUC_VERSION_FILE}"
+            ADUC_STORAGE_PATH="${ADUC_STORAGE_PATH}")
 
 if (ADUC_BUILD_UNIT_TESTS)
     add_subdirectory (tests)
diff --git a/src/platform_layers/linux_platform_layer/src/linux_device_info_exports.cpp b/src/platform_layers/linux_platform_layer/src/linux_device_info_exports.cpp
index 5a6ab62..b3837bb 100644
--- a/src/platform_layers/linux_platform_layer/src/linux_device_info_exports.cpp
+++ b/src/platform_layers/linux_platform_layer/src/linux_device_info_exports.cpp
@@ -449,7 +449,7 @@ static char* DeviceInfo_GetTotalStorage()
     {
     };
 
-    if (statvfs("/", &buf) == -1)
+    if (statvfs(ADUC_STORAGE_PATH, &buf) == -1)
     {
         Log_Error("statvfs failed, error: %d", errno);
         return nullptr;
diff --git a/src/utils/eis_utils/src/eis_coms.c b/src/utils/eis_utils/src/eis_coms.c
index dba6c64..cb25857 100644
--- a/src/utils/eis_utils/src/eis_coms.c
+++ b/src/utils/eis_utils/src/eis_coms.c
@@ -140,7 +140,7 @@ typedef struct tagEIS_HTTP_WORKLOAD_CONTEXT
 /**
  * @brief Maximum amount of bytes for any EIS response
  */
-#define EIS_RESP_SIZE_MAX 4096
+#define EIS_RESP_SIZE_MAX 16384
 
 //
 // HTTP Functions
